# DataStructure 알아보기!😀

<h2>1.스택(Stack)</h2>
•LIFO(List In First Out: 후입선출) 원리에 따라 정렬된 컬렉션. 항상 동일한 종단점에서 추가/삭제된다. 예) 책더미나 쌓여있는 석판
&nbsp;<h3>1) 스택만들기</h3>
•push(element) : 스택 꼭대기에 새 원소를 추가한다.<br/>
•pop() : 스택 꼭대기에 있는 원소를 반환하고 해당 원소는 스택에서 삭제한다.<br/>
•peak() : 스택 꼭대기에 있는 원소를 반환하되 스택은 변경하지 않는다(스택 참조하는 용도)<br/>
•isEmpty() : 스택에 원소가 하나도 없으면 true, 스택의 크기가 0보다 크면 false를 번환한다.<br/>
•clear() : 스택의 모든 원소를 삭제한다.<br/>
•size() : 스택의 원소 개수를 반환한다. 배열의 length 프로퍼티와 비슷하다. <br/>
<br/>
<h2>2.큐(Queue)</h2>
•FIFO(First In First Out: 선입선출) 원리에 따라 정렬된 컬렉션. <br/>&nbsp;새원소는 뒤로 들어가서 앞에서 빠져나가는 구조로, 마지막에 추가된 원소는 큐의 뒷부분에서 제일 오래 기다려야 한다. 예) 매표소
&nbsp;<h3>1) 큐만들기</h3>
•enqueue(element) : 큐의 뒤쪽에 원소들을 추가한다.<br/>
•dequeue() : 큐의 첫번째 원소를 반환하고 큐에서 삭제한다.<br/>
•front() : 큐의 첫번째 요소를 반환하되 큐 자체는 그대로 둔다.<br/>
•isEmpty() : 큐가 비어있다면 true, 그 외에는 false를 반환한다.<br/>
•size() : 큐의 원소 개수를 반환한다.
&nbsp;<h3>2) 우선순위 큐</h3>
•원소가 우선순위에 따라 추가/삭제, 우선순위의 값이 작을수록 앞자리도 이동시킨다.(1이 가장 높은 우숸순위를 갖는다.)
<br/>
<h2>3.링크드 리스트(Linked List)</h2>
•동적인 자료구조로, 필요할 때마다 원소를 추가/삭제할 수 있고 크기가 계속 변한다. 예) 기차<br/>
&nbsp;각원소는 원소 자신과 다음 원소를 가리치는 참조정보(포인터, 링크)가 포함된 노드로 구성된다.<br/>
&nbsp;원소 추가/삭제 시 다른 원소들을 이동하지 않아도 된다는 점이 배열보다 낫다.<br/>
&nbsp;원소를 찾을때까지 처음(head)부터 루프를 반복해야한다.
&nbsp;<h3>1) 큐만들기</h3>
•append(element) : 리스트의 맨 끝에 원소를 추가한다.<br/>
•removeAt(element) : 원소를 삭제한다. 삭제하려는 원소가 리스트의 첫번째 원소인지 아닌지에 따라 두가지 경로를 생각해야 한다.<br/>
•insert(position, element) : 임의의 위치에 원소를 삽입한다.<br/>
•toString() : 객체를 문자열로 반환한다.<br/>
•indexOf(element) : 원소 값을 인자로 받아 리스트에서 해당원소의 인덱스를 반환한다. 없으면 -1을 반환한다.<br/>
•remove(element) : 원소를 삭제한다.
<br/>
<h2>4.집합(Set)</h2>
•정렬되지 않은 컬렉션으로 원소는 반복되지 않는다.<br/>
&nbsp;집합자료구조는 수학책에 나오는 유한 집합(finile set)의 개념을 과학에 적용한 것이다.<br/>
&nbsp;유일하게 구분되는 원소의 모임<br/>
•널집합 또는 공집합 : 원소가 하나도 없는 집합, 중괄호({})로 표시한다. 가령 24와 29사이의 소수의 집합<br/>
<h3>4-1)집합 만들기</h3>
•has(element) : 어떤 원소가 집합에 포함되어 있는지 여부를 true/false로 반환한다.<br/>
•add(element) : 원소를 추가한다.<br/>
•remove(element) : 원소를 삭제한다.<br/>
•clear() : 모든 원소를 삭제한다.<br/>
•size() : 원소의 개수를 반환한다.<br/>
•values() : 집합의 모든 원소를 배열 형태로 반환한다.<br/>
<h3>4-2)집합 연산</h3>
•합집합(union) : 두 집합 중 어느 한 쪽이라도 포함된 원소로 구성된 집합. A∪B = {x|x∈ A Vx ∈ B}<br/>
•교집합(inersection) : 두 집합 모두 포함되어 있는 원소로 구성된 집합. A∩B = {x|x∈ A ∧x ∈ B}<br/>
•차집합(difference) : 첫번째 집합에는 있지만 두번째 집합에는 없는 원소로 구성된 집합. A-B = {x|x∈ A ∧x∉B}<br/>
•부분집합(subset) : 어떤 집합이 다른 집합의 일부인지 확인한다. A⊆B = ∀x{x∈A=>x∈B}
<br/>
<h2>5.딕셔너리 및 해쉬테이블</h2>
<h3>5-1)딕셔너리</h3>
•딕셔너리 : 데이터를 키, 값 쌍으로 담아두는 자료구조. 키는 원소를 찾기위한 식별자이며 맵이라고도 한다.
<h3>5-1-1)딕셔너리</h3>
•has(key) : 키에 해당하는 원소가 딕셔너리에 존재하면 true, 그렇지 않으면 false.<br/>
•set(key,value) : 딕셔너리에 원소를 추가<br/>
•remove(key) : 키에 해당하는 원소를 삭제<br/>
•get(key) : 키에 해당하는 원소의 값을 반환<br/>
•value() : 딕셔너리의 모든 값을 배열로 반환<br/>
<h3>5-2)해쉬테이블</h3>
•해쉬테이블 : 자료구조에서 특정값을 가장 신속하게 찾는 방법,어떤 키에 해당하는 값의 주소를 테이블에서 차자아주는 함수, <br/>조회속도가 매우빠르고 간단하다.<br/>
<h3>5-2-1)해쉬테이블 만들기</h3>
•put(key, value) : 원소를 추가 또는 기존 원소를 수정<br/>
•get(key) : 키에 해당하는 원소를 차자아 그 값을 반환<br/>
•remove(key) : 키에 해당하는 원소를 찾아 삭제<br/>
<h3>5-2-2)체이닝(chainning) 및 선형탐색법(linear probing)</h3>
•체이닝 : 테이블의 인덱스별로 연결리스트를 생성해 그 안에 원소를 저장하는 기법.<br/>
충동을 해결하는 가장 단순한 방법이나, hashtable 인스턴스 외에 메모리가 추가적으로 소요된다는 단점이 있다.<br/>
•선형 탐색법 : 새 원소 추가시 인덱스가 이미 점유된 상태라면 인덱스에 1을 더해 찾아보고, <br/>인덱스+1도 점유됐다면 인덱스+2를 찾아보는 식으로 충돌을 회피한다.
<br/>
<h2>6.트리</h2>
•트리 : 정보를 쉽게 검색하기 위해 저장할 떄 유용한 자료구조로 계층구조를 추상화한 모덱 예) 가계도, 회사조직<br/>
부모 - 자식 관계를 가진 다수의 노드로 구성, 각 노드는 부모 노드를 가지며, 다수 자식 노드를 가질 수 있고, 하나도 없을 수도 있다.
<h3>6-1)트리용어</h3>
•루트 : 최상위 노드, 부모가 없는 노드<br/>
•내부노드 : 1개 이상의 자식을 가진 노드<br/>
•외부노드 또는 리프 : 자식이 하나도 없는 노드<br/>
•서브트리 : 노드와 후손으로 구성<br/>
•노드의 깊이 : 조상의 개수<br/>
•트리의 깊이 : 깊이의 최대치, 루트는ㄴ 레벨 0; 하위 자식은 레벨 1
<h3>6-2)이진트리와 이진탐색트리</h3>
•이진트리 : 좌우측에 각각 하나씩 최대 2개의 자식 노드를 갖는다. <br.>따라서 노드의 삽입, 조회, 삭제를 효과적으로 수행할 수 있어서 컴퓨터 과학에서 아주 폭넓게 활용한다.
•이진탐색트리 : 이진트리의 변형으로, 좌측 노드에는 더작은 값을, 우측 노드에는 더 큰 값을 들고 있다.
<h3>6-3)트리 순회</h3>
•트리순회 : 트리의 모든 노드를 방문해서 각 노드마다 어떤 작업을 수행하는 것.<br/>
•중위순회(inorder traversal) : BST의 노드를 오름차순, 즉 작은 값에서 큰 값 방향으로 방문, 트리 정렬시 사용되는 방법.<br/>
•전위순회(preorder traversal) : 자식노드보다 노드 자신을 먼저 방문, 구조화된 문서를 출력할 떄 많이 이용하는 방법.<br/>
•후위순회(postorder traversal) : 자식 노드를 노드 자신보다 먼저 방문, 디렉토리와 서브 디렉토리의 파일 용량을 계산할 떄 쓰는 방법
