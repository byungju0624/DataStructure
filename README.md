# DataStructure 알아보기!😀

<h2>1.스택(Stack)</h2>
•LIFO(List Imn First Out: 후입선출) 원리에 따라 정렬된 컬렉션. 항상 동일한 종단점에서 추가/삭제된다. 예) 책더미나 쌓여있는 석판
&nbsp;<h3>1) 스택만들기</h3>
•push(element) : 스택 꼭대기에 새 원소를 추가한다.<br/>
•pop() : 스택 꼭대기에 있는 원소를 반환하고 해당 원소는 스택에서 삭제한다.<br/>
•peak() : 스택 꼭대기에 있는 원소를 반환하되 스택은 변경하지 않는다(스택 참조하는 용도)<br/>
•isEmpty() : 스택에 원소가 하나도 없으면 true, 스택의 크기가 0보다 크면 false를 번환한다.<br/>
•clear() : 스택의 모든 원소를 삭제한다.<br/>
•size() : 스택의 원소 개수를 반환한다. 배열의 length 프로퍼티와 비슷하다. <br/>
<br/>
<h2>2.큐(Queue)</h2>
•FIFO(First In First Out: 선입선출) 원리에 따라 정렬된 컬렉션. <br/>&nbsp;새원소는 뒤로 들어가서 앞에서 빠져나가는 구조로, 마지막에 추가된 원소는 큐의 뒷부분에서 제일 오래 기다려야 한다. 예) 매표소
&nbsp;<h3>1) 큐만들기</h3>
•enqueue(element) : 큐의 뒤쪽에 원소들을 추가한다.<br/>
•dequeue() : 큐의 첫번째 원소를 반환하고 큐에서 삭제한다.<br/>
•front() : 큐의 첫번째 요소를 반환하되 큐 자체는 그대로 둔다.<br/>
•isEmpty() : 큐가 비어있다면 true, 그 외에는 false를 반환한다.<br/>
•size() : 큐의 원소 개수를 반환한다.
&nbsp;<h3>2) 우선순위 큐</h3>
•원소가 우선순위에 따라 추가/삭제, 우선순위의 값이 작을수록 앞자리도 이동시킨다.(1이 가장 높은 우숸순위를 갖는다.)
<br/>
<h2>3.링크드 리스트(Linked List)</h2>
•동적인 자료구조로, 필요할 때마다 원소를 추가/삭제할 수 있고 크기가 계속 변한다. 예) 기차<br/>
&nbsp;각원소는 원소 자신과 다음 원소를 가리치는 참조정보(포인터, 링크)가 포함된 노드로 구성된다.<br/>
&nbsp;원소 추가/삭제 시 다른 원소들을 이동하지 않아도 된다는 점이 배열보다 낫다.<br/>
&nbsp;원소를 찾을때까지 처음(head)부터 루프를 반복해야한다.
&nbsp;<h3>1) 큐만들기</h3>
•append(element) : 리스트의 맨 끝에 원소를 추가한다.<br/>
•removeAt(element) : 원소를 삭제한다. 삭제하려는 원소가 리스트의 첫번째 원소인지 아닌지에 따라 두가지 경로를 생각해야 한다.<br/>
•insert(position, element) : 임의의 위치에 원소를 삽입한다.<br/>
•toString() : 객체를 문자열로 반환한다.<br/>
•indexOf(element) : 원소 값을 인자로 받아 리스트에서 해당원소의 인덱스를 반환한다. 없으면 -1을 반환한다.<br/>
•remove(element) : 원소를 삭제한다.
